/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GalleryXPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// tagCache.ts
var GlobalTagCache = class {
  constructor() {
    this.tagCache = /* @__PURE__ */ new Set();
  }
  static getInstance() {
    if (!GlobalTagCache.instance) {
      GlobalTagCache.instance = new GlobalTagCache();
    }
    return GlobalTagCache.instance;
  }
  addTag(tag) {
    this.tagCache.add(tag.toLowerCase());
  }
  removeTag(tag) {
    this.tagCache.delete(tag.toLowerCase());
  }
  hasTag(tag) {
    return this.tagCache.has(tag.toLowerCase());
  }
  getAllTags() {
    return Array.from(this.tagCache);
  }
  clear() {
    this.tagCache.clear();
  }
};

// fullscreen.ts
var FullscreenView = class {
  constructor(app, items, startIndex, resolveLocalPath) {
    this.tagInput = null;
    this.suggestionsContainer = null;
    this.selectedSuggestionIndex = -1;
    this.app = app;
    this.items = items.filter((item) => item && !item.isVideo);
    this.currentIndex = this.items.findIndex((item) => {
      var _a;
      return item.src === ((_a = items[startIndex]) == null ? void 0 : _a.src);
    });
    if (this.currentIndex === -1)
      this.currentIndex = 0;
    this.currentItem = this.items[this.currentIndex] || this.items[0];
    this.resolveLocalPath = resolveLocalPath;
    this.createContainer();
    this.tagCache = GlobalTagCache.getInstance();
    this.initializeTagCache();
  }
  initializeTagCache() {
    this.items.forEach((item) => {
      item.tags.forEach((tag) => this.tagCache.addTag(tag));
    });
  }
  createContainer() {
    var _a, _b, _c;
    this.container = document.createElement("div");
    this.container.className = "galleryx-fullscreen-container";
    this.container.style.position = "fixed";
    this.container.style.top = "0";
    this.container.style.left = "0";
    this.container.style.width = "100%";
    this.container.style.height = "100%";
    this.container.style.backgroundColor = "rgba(0, 0, 0, 0.9)";
    this.container.style.zIndex = "9999";
    this.container.innerHTML = `
            <div class="galleryx-fullscreen-content" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;"></div>
            <div class="galleryx-fullscreen-metadata" style="position: absolute; bottom: 10px; left: 10px; right: 10px; color: white; width: 100%;"></div>
            <button class="galleryx-fullscreen-close" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">\xD7</button>
            ${this.items.length > 1 ? `
                <button class="galleryx-fullscreen-prev" style="position: absolute; top: 50%; left: 10px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">\u2039</button>
                <button class="galleryx-fullscreen-next" style="position: absolute; top: 50%; right: 10px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">\u203A</button>
            ` : ""}
        `;
    (_a = this.container.querySelector(".galleryx-fullscreen-close")) == null ? void 0 : _a.addEventListener("click", () => this.close());
    if (this.items.length > 1) {
      (_b = this.container.querySelector(".galleryx-fullscreen-prev")) == null ? void 0 : _b.addEventListener("click", () => this.navigate(-1));
      (_c = this.container.querySelector(".galleryx-fullscreen-next")) == null ? void 0 : _c.addEventListener("click", () => this.navigate(1));
    }
    this.container.addEventListener("click", (e) => {
      if (e.target === this.container) {
        this.close();
      }
    });
    document.addEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.appendChild(this.container);
    this.updateContent();
  }
  updateContent() {
    const contentEl = this.container.querySelector(".galleryx-fullscreen-content");
    const metadataEl = this.container.querySelector(".galleryx-fullscreen-metadata");
    if (!contentEl || !metadataEl)
      return;
    contentEl.innerHTML = "";
    const img = document.createElement("img");
    img.className = "galleryx-fullscreen-image";
    if (this.currentItem.isLocal) {
      img.src = this.resolveLocalPath(this.currentItem.src);
    } else {
      img.src = this.currentItem.src;
    }
    img.onerror = () => this.handleMediaError(contentEl, "Image failed to load");
    img.style.maxWidth = "100%";
    img.style.maxHeight = "100%";
    img.style.objectFit = "contain";
    img.style.transition = "transform 0.1s ease-out";
    contentEl.appendChild(img);
    metadataEl.innerHTML = `
        <div style="display: flex; width: 100%; max-width: 100%; background-color: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px;">
            <div style="flex: 0 0 auto; margin-right: 20px;">
                <p style="margin: 0 0 5px 0;">Source:</p>
                <p style="margin: 0 0 10px 0; word-break: break-all;">${this.currentItem.src}</p>
                <button class="galleryx-copy-metadata" style="background: none; border: 1px solid white; color: white; padding: 5px 10px; cursor: pointer;">Copy Source</button>
            </div>
            <div style="flex: 1; overflow: hidden;">
                <p style="margin: 0 0 5px 0;">Tags:</p>
                <input type="text" class="galleryx-tags-input" value="${this.currentItem.tags.join(", ")}" style="width: 100%; background: rgba(255,255,255,0.1); color: white; border: none; padding: 5px;">
                <button class="galleryx-update-tags" style="background: none; border: 1px solid white; color: white; padding: 5px 10px; cursor: pointer; margin-top: 5px;">Update Tags</button>
            </div>
        </div>
    `;
    const copyButton = metadataEl.querySelector(".galleryx-copy-metadata");
    copyButton == null ? void 0 : copyButton.addEventListener("click", () => this.copyMetadataToClipboard());
    const updateTagsButton = metadataEl.querySelector(".galleryx-update-tags");
    const tagsInput = metadataEl.querySelector(".galleryx-tags-input");
    this.tagInput = tagsInput;
    this.clearSuggestions();
    if (this.suggestionsContainer) {
      this.suggestionsContainer.remove();
    }
    this.suggestionsContainer = document.createElement("div");
    this.suggestionsContainer.className = "galleryx-tag-suggestions";
    document.body.appendChild(this.suggestionsContainer);
    tagsInput.addEventListener("input", () => this.showSuggestions());
    tagsInput.addEventListener("keydown", (e) => this.handleTagInputKeydown(e));
    updateTagsButton == null ? void 0 : updateTagsButton.addEventListener("click", () => {
      const newTags = tagsInput.value.split(",").map((tag) => tag.trim()).filter((tag) => tag);
      this.updateTags(newTags);
    });
    let scale = 1;
    contentEl.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      scale *= delta;
      scale = Math.min(Math.max(0.5, scale), 5);
      updateTransform();
    });
    let isDragging = false;
    let startX, startY;
    let translateX = 0, translateY = 0;
    img.addEventListener("mousedown", (e) => {
      if (e.button === 2) {
        e.preventDefault();
        isDragging = true;
        startX = e.clientX - translateX;
        startY = e.clientY - translateY;
      }
    });
    this.handleMouseMove = (e) => {
      if (isDragging) {
        translateX = e.clientX - startX;
        translateY = e.clientY - startY;
        updateTransform();
      }
    };
    this.handleMouseUp = () => {
      isDragging = false;
    };
    document.addEventListener("mousemove", this.handleMouseMove);
    document.addEventListener("mouseup", this.handleMouseUp);
    const updateTransform = () => {
      img.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
    };
  }
  handleMediaError(contentEl, message) {
    contentEl.innerHTML = `<div class="galleryx-error-message">${message}</div>`;
  }
  copyMetadataToClipboard() {
    const metadata = `${this.currentItem.src}`;
    navigator.clipboard.writeText(metadata).then(() => {
      const copyButton = this.container.querySelector(".galleryx-copy-metadata");
      if (copyButton) {
        const originalText = copyButton.textContent;
        copyButton.textContent = "Copied!";
        setTimeout(() => {
          copyButton.textContent = originalText;
        }, 2e3);
      }
    }).catch((err) => {
      console.error("Failed to copy metadata: ", err);
    });
  }
  showSuggestions() {
    var _a;
    if (!this.tagInput || !this.suggestionsContainer)
      return;
    const inputValue = this.tagInput.value.toLowerCase();
    const lastTag = ((_a = inputValue.split(",").pop()) == null ? void 0 : _a.trim()) || "";
    if (lastTag.length === 0) {
      this.suggestionsContainer.style.display = "none";
      return;
    }
    const suggestions = this.tagCache.getAllTags().filter((tag) => tag.toLowerCase().includes(lastTag)).sort((a, b) => a.localeCompare(b));
    this.suggestionsContainer.innerHTML = "";
    suggestions.forEach((suggestion, index) => {
      var _a2;
      const suggestionEl = document.createElement("div");
      suggestionEl.textContent = suggestion;
      suggestionEl.className = "galleryx-tag-suggestion";
      suggestionEl.style.padding = "5px";
      suggestionEl.style.cursor = "pointer";
      suggestionEl.addEventListener("click", () => this.selectSuggestion(suggestion));
      suggestionEl.addEventListener("mouseover", () => this.setSelectedSuggestion(index));
      (_a2 = this.suggestionsContainer) == null ? void 0 : _a2.appendChild(suggestionEl);
    });
    if (this.suggestionsContainer) {
      const inputRect = this.tagInput.getBoundingClientRect();
      this.suggestionsContainer.style.position = "absolute";
      this.suggestionsContainer.style.left = `${inputRect.left}px`;
      this.suggestionsContainer.style.bottom = `${window.innerHeight - inputRect.top}px`;
      this.suggestionsContainer.style.width = `${inputRect.width}px`;
      this.suggestionsContainer.style.maxHeight = "150px";
      this.suggestionsContainer.style.overflowY = "auto";
      this.suggestionsContainer.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
      this.suggestionsContainer.style.color = "white";
      this.suggestionsContainer.style.zIndex = "10000";
      this.suggestionsContainer.style.display = suggestions.length > 0 ? "block" : "none";
    }
    this.selectedSuggestionIndex = -1;
  }
  selectSuggestion(suggestion) {
    if (!this.tagInput)
      return;
    const tags = this.tagInput.value.split(",");
    tags[tags.length - 1] = suggestion;
    this.tagInput.value = tags.join(", ") + ", ";
    this.suggestionsContainer.style.display = "none";
    this.tagInput.focus();
  }
  setSelectedSuggestion(index) {
    this.selectedSuggestionIndex = index;
    const suggestions = this.suggestionsContainer.children;
    for (let i = 0; i < suggestions.length; i++) {
      suggestions[i].classList.toggle("selected", i === index);
    }
  }
  clearSuggestions() {
    if (this.suggestionsContainer) {
      this.suggestionsContainer.innerHTML = "";
      this.suggestionsContainer.style.display = "none";
    }
    this.selectedSuggestionIndex = -1;
  }
  handleTagInputKeydown(event) {
    if (!this.suggestionsContainer)
      return;
    const suggestions = this.suggestionsContainer.children;
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        this.setSelectedSuggestion((this.selectedSuggestionIndex + 1) % suggestions.length);
        break;
      case "ArrowUp":
        event.preventDefault();
        this.setSelectedSuggestion((this.selectedSuggestionIndex - 1 + suggestions.length) % suggestions.length);
        break;
      case "Enter":
        if (this.selectedSuggestionIndex >= 0) {
          event.preventDefault();
          this.selectSuggestion(suggestions[this.selectedSuggestionIndex].textContent);
        }
        break;
      case "Escape":
        this.suggestionsContainer.style.display = "none";
        break;
    }
  }
  async updateTags(newTags) {
    const oldTags = new Set(this.currentItem.tags);
    this.currentItem.tags = newTags;
    newTags.forEach((tag) => this.tagCache.addTag(tag));
    oldTags.forEach((tag) => {
      if (!this.items.some((item) => item.tags.includes(tag))) {
        this.tagCache.removeTag(tag);
      }
    });
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let updated = false;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes(this.currentItem.src)) {
          const tagRegex = /\{.*?\}/;
          if (tagRegex.test(lines[i])) {
            lines[i] = lines[i].replace(tagRegex, `{${newTags.join(", ")}}`);
          } else {
            lines[i] += ` {${newTags.join(", ")}}`;
          }
          updated = true;
          break;
        }
      }
      if (updated) {
        await this.app.vault.modify(file, lines.join("\n"));
        break;
      }
    }
    this.updateContent();
  }
  navigate(direction) {
    if (this.items.length > 1) {
      this.currentIndex = (this.currentIndex + direction + this.items.length) % this.items.length;
      this.currentItem = this.items[this.currentIndex];
      this.clearSuggestions();
      this.updateContent();
    }
  }
  handleKeyDown(event) {
    if (this.tagInput && document.activeElement === this.tagInput) {
      if (event.key === "Escape") {
        this.tagInput.blur();
        event.preventDefault();
      } else if (event.key === "Enter") {
        event.preventDefault();
        const newTags = this.tagInput.value.split(",").map((tag) => tag.trim()).filter((tag) => tag);
        this.updateTags(newTags);
      }
      return;
    }
    switch (event.key) {
      case "ArrowLeft":
        this.navigate(-1);
        break;
      case "ArrowRight":
        this.navigate(1);
        break;
      case "Escape":
        this.close();
        break;
    }
  }
  close() {
    document.removeEventListener("keydown", this.handleKeyDown);
    if (this.handleMouseMove) {
      document.removeEventListener("mousemove", this.handleMouseMove);
    }
    if (this.handleMouseUp) {
      document.removeEventListener("mouseup", this.handleMouseUp);
    }
    this.clearSuggestions();
    if (this.suggestionsContainer) {
      this.suggestionsContainer.remove();
      this.suggestionsContainer = null;
    }
    this.container.remove();
  }
};

// gallerySearch.ts
var GallerySearch = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async processGallerySearch(source, el) {
    const lines = source.split("\n");
    const { tags, limit } = this.parseSearchSettings(lines);
    const items = await this.findMatchingItems(tags);
    const containerEl = document.createElement("div");
    containerEl.className = "galleryx-search-container";
    const searchInputEl = this.createSearchInput(items, containerEl, limit);
    containerEl.appendChild(searchInputEl);
    const galleryEl = document.createElement("div");
    galleryEl.className = "galleryx-search-gallery";
    containerEl.appendChild(galleryEl);
    el.appendChild(containerEl);
  }
  parseSearchSettings(lines) {
    let tags = [];
    let limit = 50;
    lines.forEach((line) => {
      if (line.startsWith("tags:")) {
        tags = line.substring(5).split(",").map((tag) => tag.trim());
      } else if (line.startsWith("limit:")) {
        limit = parseInt(line.substring(6).trim(), 10) || 50;
      }
    });
    return { tags, limit };
  }
  async findMatchingItems(searchTags) {
    const matchingItems = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const galleryBlocks = this.extractGalleryBlocks(content);
      galleryBlocks.forEach((block) => {
        const items = this.plugin.parseGalleryItems(block.split("\n"));
        items.forEach((item) => {
          if (this.itemMatchesTags(item, searchTags)) {
            matchingItems.push(item);
          }
        });
      });
    }
    return matchingItems;
  }
  extractGalleryBlocks(content) {
    const regex = /```galleryx([\s\S]*?)```/g;
    const matches = [];
    let match;
    while ((match = regex.exec(content)) !== null) {
      matches.push(match[1].trim());
    }
    return matches;
  }
  itemMatchesTags(item, searchTags) {
    return searchTags.every((tag) => item.tags.some((itemTag) => itemTag.toLowerCase().includes(tag.toLowerCase())));
  }
  createSearchInput(items, containerEl, limit) {
    const searchContainer = document.createElement("div");
    searchContainer.className = "galleryx-search-input-container";
    const inputWrapper = document.createElement("div");
    inputWrapper.className = "galleryx-input-wrapper";
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.placeholder = "Search tags...";
    searchInput.className = "galleryx-search-input";
    const suggestionContainer = document.createElement("div");
    suggestionContainer.className = "galleryx-suggestion-container";
    suggestionContainer.style.display = "none";
    inputWrapper.appendChild(searchInput);
    inputWrapper.appendChild(suggestionContainer);
    const searchButton = document.createElement("button");
    searchButton.textContent = "Search";
    searchButton.className = "galleryx-search-button";
    const clearButton = document.createElement("button");
    clearButton.textContent = "Clear";
    clearButton.className = "galleryx-clear-button";
    searchContainer.appendChild(inputWrapper);
    searchContainer.appendChild(searchButton);
    searchContainer.appendChild(clearButton);
    const performSearch = () => {
      if (searchInput.value.trim() !== "") {
        this.updateGalleryWithSearch(searchInput.value, items, containerEl, limit);
        suggestionContainer.style.display = "none";
      }
    };
    searchInput.addEventListener("input", () => {
      this.updateSuggestions(searchInput.value, suggestionContainer);
    });
    searchInput.addEventListener("focus", () => {
      if (searchInput.value.trim() !== "") {
        this.updateSuggestions(searchInput.value, suggestionContainer);
      }
    });
    searchInput.addEventListener("blur", () => {
      setTimeout(() => {
        suggestionContainer.style.display = "none";
      }, 200);
    });
    searchInput.addEventListener("keyup", (event) => {
      if (event.key === "Enter") {
        performSearch();
      }
    });
    searchButton.addEventListener("click", performSearch);
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      suggestionContainer.style.display = "none";
      this.clearGallery(containerEl);
    });
    return searchContainer;
  }
  updateSuggestions(input, suggestionContainer) {
    const tagCache = GlobalTagCache.getInstance();
    const allTags = tagCache.getAllTags();
    const inputTags = input.toLowerCase().split(",").map((tag) => tag.trim());
    const currentTag = inputTags[inputTags.length - 1];
    if (currentTag.length === 0) {
      suggestionContainer.style.display = "none";
      return;
    }
    const matchingTags = allTags.filter((tag) => tag.toLowerCase().includes(currentTag) && !inputTags.slice(0, -1).includes(tag.toLowerCase()));
    suggestionContainer.innerHTML = "";
    if (matchingTags.length > 0) {
      matchingTags.slice(0, 5).forEach((tag) => {
        const suggestionEl = document.createElement("div");
        suggestionEl.className = "galleryx-suggestion";
        suggestionEl.textContent = tag;
        suggestionEl.addEventListener("click", () => {
          inputTags[inputTags.length - 1] = tag;
          const newInput = inputTags.join(", ");
          suggestionContainer.previousElementSibling.value = newInput;
          this.updateSuggestions(newInput, suggestionContainer);
        });
        suggestionContainer.appendChild(suggestionEl);
      });
      suggestionContainer.style.display = "block";
    } else {
      suggestionContainer.style.display = "none";
    }
  }
  updateGalleryWithSearch(searchInput, items, containerEl, limit) {
    const searchTags = searchInput.toLowerCase().split(",").map((tag) => tag.trim());
    const filteredItems = items.filter((item) => this.itemMatchesTags(item, searchTags));
    this.updateGalleryContent(filteredItems, containerEl, limit);
  }
  clearGallery(containerEl) {
    const galleryEl = containerEl.querySelector(".galleryx-search-gallery");
    if (galleryEl) {
      galleryEl.innerHTML = "";
    }
  }
  updateGalleryContent(items, containerEl, limit) {
    const galleryEl = containerEl.querySelector(".galleryx-search-gallery");
    if (galleryEl) {
      galleryEl.innerHTML = "";
      const newGallery = this.createPaginatedGallery(items, limit);
      galleryEl.appendChild(newGallery);
    }
  }
  createPaginatedGallery(items, limit) {
    const galleryEl = document.createElement("div");
    galleryEl.className = "galleryx-search-gallery";
    const totalPages = Math.ceil(items.length / limit);
    let currentPage = 1;
    const updateGallery = () => {
      galleryEl.innerHTML = "";
      const start = (currentPage - 1) * limit;
      const end = Math.min(start + limit, items.length);
      const pageItems = items.slice(start, end);
      const pageGallery = this.plugin.createGalleryElement(pageItems, { type: "flexbox", flexboxHeight: "295px" });
      galleryEl.appendChild(pageGallery);
      const paginationEl = document.createElement("div");
      paginationEl.className = "galleryx-pagination";
      paginationEl.innerHTML = `Page ${currentPage} of ${totalPages}`;
      if (currentPage > 1) {
        const prevButton = document.createElement("button");
        prevButton.textContent = "Previous";
        prevButton.addEventListener("click", () => {
          currentPage--;
          updateGallery();
        });
        paginationEl.appendChild(prevButton);
      }
      if (currentPage < totalPages) {
        const nextButton = document.createElement("button");
        nextButton.textContent = "Next";
        nextButton.addEventListener("click", () => {
          currentPage++;
          updateGallery();
        });
        paginationEl.appendChild(nextButton);
      }
      galleryEl.appendChild(paginationEl);
    };
    updateGallery();
    return galleryEl;
  }
};

// main.ts
var GalleryXPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.items = [];
  }
  async onload() {
    console.log("Loading GalleryX plugin");
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
  }
  async onLayoutReady() {
    this.registerMarkdownCodeBlockProcessor("galleryx", this.processGalleryBlock.bind(this));
    this.registerMarkdownPostProcessor(this.processInlineGallery.bind(this));
    this.registerMarkdownCodeBlockProcessor("gallery-search", this.processGallerySearch.bind(this));
    await this.populateGlobalTagCache();
    this.registerEvent(this.app.vault.on("modify", async (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        const content = await this.app.vault.read(file);
        if (this.containsGalleryElement(content)) {
          await this.updateTagCacheForFile(file, content);
        }
      }
    }));
    console.log("GalleryX plugin fully loaded and tag cache populated");
  }
  async populateGlobalTagCache() {
    const tagCache = GlobalTagCache.getInstance();
    if (!this.app.vault) {
      console.error("Unable to access the vault");
      return;
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      if (this.containsGalleryElement(content)) {
        await this.updateTagCacheForFile(file, content);
      }
    }
  }
  containsGalleryElement(content) {
    if (content.includes("```galleryx")) {
      return true;
    }
    if (content.includes("`galleryx-single:")) {
      return true;
    }
    return false;
  }
  async updateTagCacheForFile(file, content) {
    const tagCache = GlobalTagCache.getInstance();
    try {
      if (!content) {
        content = await this.app.vault.read(file);
      }
      const tags = this.extractTagsFromContent(content);
      tags.forEach((tag) => tagCache.addTag(tag));
    } catch (error) {
      console.error(`Error processing file ${file.path}:`, error);
    }
  }
  extractTagsFromContent(content) {
    const tagRegex = /\{(.*?)\}/g;
    const tags = [];
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      const tagString = match[1];
      const individualTags = tagString.split(",").map((tag) => tag.trim());
      tags.push(...individualTags);
    }
    return tags;
  }
  onunload() {
    console.log("Unloading GalleryX plugin");
  }
  processGallerySearch(source, el, ctx) {
    const gallerySearch = new GallerySearch(this.app, this);
    gallerySearch.processGallerySearch(source, el);
  }
  processGalleryBlock(source, el, ctx) {
    const lines = source.split("\n");
    const { settings, contentStartIndex } = this.extractSettings(lines);
    const items = this.parseGalleryItems(lines.slice(contentStartIndex));
    const galleryEl = this.createGalleryElement(items, settings);
    el.appendChild(galleryEl);
  }
  extractSettings(lines) {
    let settings = { type: "flexbox" };
    let contentStartIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.startsWith("settings:") || line.startsWith("flexboxheight:") || line.startsWith("columns:")) {
        const parsedSettings = this.parseSettings(line);
        settings = { ...settings, ...parsedSettings };
        contentStartIndex = i + 1;
      } else {
        break;
      }
    }
    return { settings, contentStartIndex };
  }
  parseSettings(settingsLine) {
    const settings = {};
    const typeMatch = settingsLine.match(/settings:\s*(\w+)/);
    if (typeMatch) {
      settings.type = typeMatch[1];
    }
    const flexboxHeightMatch = settingsLine.match(/flexboxheight:\s*(\d+px)/);
    if (flexboxHeightMatch) {
      settings.flexboxHeight = flexboxHeightMatch[1];
    }
    const columnsMatch = settingsLine.match(/columns:\s*(\d+)/);
    if (columnsMatch) {
      settings.columns = parseInt(columnsMatch[1]);
    }
    return settings;
  }
  processInlineGallery(el, ctx) {
    const codeBlocks = el.querySelectorAll("code, pre > code");
    codeBlocks.forEach((code) => {
      var _a, _b, _c;
      if (code.className === "language-galleryx-single" || ((_a = code.textContent) == null ? void 0 : _a.trim().startsWith("galleryx-single:"))) {
        let content = ((_b = code.textContent) == null ? void 0 : _b.trim()) || "";
        if (content.startsWith("galleryx-single:")) {
          content = content.substring("galleryx-single:".length).trim();
        }
        const item = this.parseGalleryItems([content])[0];
        if (item) {
          const galleryEl = this.createGalleryElement([item], { type: "single" });
          const wrapper = document.createElement("div");
          wrapper.className = "galleryx-single-wrapper";
          wrapper.appendChild(galleryEl);
          ctx.addChild(new import_obsidian.MarkdownRenderChild(wrapper));
          if (((_c = code.parentElement) == null ? void 0 : _c.tagName) === "PRE") {
            code.parentElement.replaceWith(wrapper);
          } else {
            code.replaceWith(wrapper);
          }
        }
      }
    });
  }
  createFilterElement(items, galleryEl) {
    const filterContainer = document.createElement("div");
    filterContainer.className = "galleryx-filter-container";
    const filterInput = document.createElement("input");
    filterInput.type = "text";
    filterInput.placeholder = "Filter by tags...";
    filterInput.className = "galleryx-filter-input";
    const suggestionContainer = document.createElement("div");
    suggestionContainer.className = "galleryx-suggestion-container";
    suggestionContainer.style.display = "none";
    const filterButton = document.createElement("button");
    filterButton.textContent = "Filter";
    filterButton.className = "galleryx-filter-button";
    const clearButton = document.createElement("button");
    clearButton.textContent = "Clear";
    clearButton.className = "galleryx-clear-button";
    filterContainer.appendChild(filterInput);
    filterContainer.appendChild(suggestionContainer);
    filterContainer.appendChild(filterButton);
    filterContainer.appendChild(clearButton);
    const applyFilter = () => this.filterGallery(items, galleryEl, filterInput.value);
    filterButton.addEventListener("click", applyFilter);
    clearButton.addEventListener("click", () => {
      filterInput.value = "";
      this.filterGallery(items, galleryEl, "");
      suggestionContainer.style.display = "none";
    });
    filterInput.addEventListener("input", () => {
      this.updateSuggestions(filterInput.value, suggestionContainer);
    });
    filterInput.addEventListener("keyup", (event) => {
      if (event.key === "Enter") {
        applyFilter();
        suggestionContainer.style.display = "none";
      }
    });
    filterInput.addEventListener("blur", (event) => {
      setTimeout(() => {
        suggestionContainer.style.display = "none";
      }, 200);
    });
    filterInput.addEventListener("input", (event) => {
      if (event.target.value === "") {
        suggestionContainer.style.display = "none";
      }
    });
    return filterContainer;
  }
  updateSuggestions(input, suggestionContainer) {
    const tagCache = GlobalTagCache.getInstance();
    const allTags = tagCache.getAllTags();
    const inputTags = input.toLowerCase().split(",").map((tag) => tag.trim());
    const currentTag = inputTags[inputTags.length - 1];
    if (currentTag.length === 0) {
      suggestionContainer.style.display = "none";
      return;
    }
    const matchingTags = allTags.filter((tag) => tag.toLowerCase().includes(currentTag) && !inputTags.slice(0, -1).includes(tag.toLowerCase()));
    suggestionContainer.innerHTML = "";
    if (matchingTags.length > 0) {
      matchingTags.slice(0, 5).forEach((tag) => {
        const suggestionEl = document.createElement("div");
        suggestionEl.className = "galleryx-suggestion";
        suggestionEl.textContent = tag;
        suggestionEl.addEventListener("click", () => {
          inputTags[inputTags.length - 1] = tag;
          const newInput = inputTags.join(", ");
          suggestionContainer.previousElementSibling.value = newInput;
          this.updateSuggestions(newInput, suggestionContainer);
        });
        suggestionContainer.appendChild(suggestionEl);
      });
      suggestionContainer.style.display = "block";
    } else {
      suggestionContainer.style.display = "none";
    }
  }
  parseGalleryItems(lines) {
    return lines.map((line) => {
      const [src, tagsString] = line.split("{");
      const trimmedSrc = src.trim();
      const isLocal = trimmedSrc.startsWith("![[") && trimmedSrc.endsWith("]]");
      const isVideo = trimmedSrc.match(/\.(mp4|webm|ogg)$/i) !== null;
      const tags = tagsString ? tagsString.replace("}", "").split(",").map((tag) => tag.trim().toLowerCase()) : [];
      return { src: trimmedSrc, isLocal, isVideo, tags };
    }).filter((item) => item.src);
  }
  createGalleryElement(items, settings) {
    if (settings.type === "single" && items.length === 1) {
      return this.createSingleGalleryItem(items[0], items);
    }
    const containerEl = document.createElement("div");
    containerEl.className = "galleryx-outer-container";
    const galleryEl = document.createElement("div");
    galleryEl.className = `galleryx-container galleryx-${settings.type}`;
    if (settings.type === "flexbox" && settings.flexboxHeight) {
      galleryEl.style.setProperty("--flexbox-height", settings.flexboxHeight);
    } else if (settings.type === "grid" && settings.columns) {
      galleryEl.style.setProperty("--columns", settings.columns.toString());
    }
    items.forEach((item, index) => {
      const itemEl = this.createGalleryItemElement(item, items, index);
      galleryEl.appendChild(itemEl);
    });
    const filterEl = this.createFilterElement(items, galleryEl);
    containerEl.appendChild(filterEl);
    containerEl.appendChild(galleryEl);
    return containerEl;
  }
  filterGallery(items, galleryEl, filterTags) {
    const tags = filterTags.toLowerCase().split(",").map((tag) => tag.trim());
    const galleryItems = galleryEl.querySelectorAll(".galleryx-item");
    galleryItems.forEach((itemEl, index) => {
      const item = items[index];
      if (tags.length === 0 || tags.every((tag) => item.tags.some((itemTag) => itemTag.toLowerCase().includes(tag)))) {
        itemEl.style.display = "";
      } else {
        itemEl.style.display = "none";
      }
    });
  }
  createGalleryItemElement(item, galleryItems, index) {
    const itemEl = document.createElement("div");
    itemEl.className = "galleryx-item";
    const contentEl = item.isVideo ? document.createElement("video") : document.createElement("img");
    contentEl.setAttribute("data-src", item.isLocal ? this.getLocalFilePath(item.src) : item.src);
    contentEl.setAttribute("loading", "lazy");
    if (item.isVideo) {
      contentEl.controls = true;
    } else {
      contentEl.alt = item.src;
      itemEl.addEventListener("click", () => this.openFullscreen(galleryItems, index));
    }
    contentEl.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3C/svg%3E';
    itemEl.appendChild(contentEl);
    this.observeElement(itemEl);
    return itemEl;
  }
  observeElement(element) {
    const observer = new IntersectionObserver((entries, observer2) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const target = entry.target;
          const dataSrc = target.getAttribute("data-src");
          if (dataSrc) {
            target.src = dataSrc;
            target.removeAttribute("data-src");
          }
          observer2.unobserve(target);
        }
      });
    }, { rootMargin: "100px" });
    observer.observe(element.firstElementChild);
  }
  createSingleGalleryItem(item, galleryItems) {
    const wrapper = document.createElement("div");
    wrapper.className = "galleryx-single-item";
    const contentEl = item.isVideo ? document.createElement("video") : document.createElement("img");
    contentEl.setAttribute("data-src", item.isLocal ? this.getLocalFilePath(item.src) : item.src);
    contentEl.setAttribute("loading", "lazy");
    if (item.isVideo) {
      contentEl.controls = true;
    } else {
      contentEl.alt = item.src;
    }
    contentEl.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3C/svg%3E';
    wrapper.appendChild(contentEl);
    if (!item.isVideo) {
      wrapper.addEventListener("click", () => this.openFullscreen(galleryItems, 0));
    }
    this.observeElement(wrapper);
    return wrapper;
  }
  getLocalFilePath(src) {
    const fileName = src.replace(/!\[\[(.*?)\]\]/, "$1");
    const file = this.app.vault.getAbstractFileByPath(fileName);
    if (file instanceof import_obsidian.TFile) {
      return this.app.vault.getResourcePath(file);
    }
    return fileName;
  }
  openFullscreen(items, startIndex) {
    const nonVideoItems = items.filter((i) => !i.isVideo);
    if (nonVideoItems.length > 0) {
      new FullscreenView(this.app, nonVideoItems, startIndex, (src) => {
        const file = this.app.vault.getAbstractFileByPath(src.replace(/!\[\[(.*?)\]\]/, "$1"));
        if (file instanceof import_obsidian.TFile) {
          return this.app.vault.getResourcePath(file);
        }
        return src;
      });
    }
  }
};
